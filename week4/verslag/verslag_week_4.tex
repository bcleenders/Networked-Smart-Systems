
\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amstext}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{float}
\usepackage[dutch]{babel}
\usepackage[section]{placeins}

\DeclareCaptionLabelFormat{andtable}{#1~#2  \&  \tablename~\thetable}


%opening
\title{Tijdsynchronisatie met Arduinos}
\author{Patrick van Looy \& Bram Leenders}

\begin{document}

\maketitle

\section{Inleiding}
Om energiezuinige draadloze communicatie mogelijk te maken, is er tijdsynchronisatie nodig tussen de verschillende nodes. Wanneer nodes gesynchroniseerd zijn kunnen ze op vaste momenten naar elkaar zenden en luisteren, en kunnen ze de rest van de tijd in een slaapstand zijn. Omdat communicatie relatief veel energie vraagt en een slaapstand zeer weinig, biedt synchronisatie dus mogelijkheden voor energiebesparing.

Tijdsynchronisatie kan op verschillende manieren geimplementeerd worden. In dit onderzoek gaan we een verschijnsel nabootsen wat we in de natuur ook kunnen vinden. De voorbeelden die hierbij gehanteerd worden, zijn vuurvliegjes en krekels. Vuurvliegjes, bijvoorbeeld, willen van nature synchroon knipperen\cite{buck1988synchronous}. Ditzelfde gedrag kan door Arduino's nagebootst worden, met behulp van radio- of geluidssignalen.

In dit onderzoek kijken we naar het Meshed Emergent Firefly Algorithm\cite{tyrrell2010emergent}, een variant op het firefly algoritme\cite{leidenfrost2009firefly, yang2013firefly}. Dit algoritme implementeren we zowel voor radiocommunicatie als voor communicatie met behulp van geluid. In sectie~\ref{sec:probleemstelling} geven we een kort overzicht van eisen waaraan het protocol dient te voldoen. Sectie~\ref{sec:radiosync} beschrijft de implementatie voor radiocommunicatie, en sectie~\ref{sec:geluidssec} beschrijft dit voor synchronisatie met behulp van geluid. In sectie~\ref{sec:resultaten} wordt besproken hoe de beide implemenaties functioneren, en geven we een korte discussie over de beide manieren van synchronisatie.

\section{Probleemstelling}\label{sec:probleemstelling}
Voor het synchroniseren van Arduino's is een synchronisatiealgoritme nodig. Het algoritme en de implementatie dienen aan de volgende eisen te voldoen:
\begin{itemize}
    \item Nodes kunnen uit een groep verdwijnen zonder rest te beinvloeden.
    \item Nodes kunnen toegevoegd worden aan een groep, en het geheel synchroniseert.
    \item Twee groepen kunnen samengevoegd worden, en het geheel synchroniseert.
    \item Wanneer nodes uit synchronisatie raken, worden deze bijgesteld.
    \item Frequentie van communicatie ligt zo laag mogelijk.
\end{itemize}

Uit deze eisen volgt dat er geen master-slave configuratie mogelijk is, omdat de master uit de groep kan verdwijnen. Er is een peer-to-peer configuratie nodig, waarbij iedere node gelijk is.

Kunnen we een synchronisatiealgoritme implementeren dat aan de eisen voldoet en volgens de genoemde configuratie werkt?

\section{Gerelateerd werk}
Patrick
\cite{tyrrell2010emergent}
Wat staat hier in: 
http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5374406

https://mobile.aau.at/publications/tyrrell-2006-minema-firefly.pdf

De vele toepassingen van draadloze (sensor)netwerken heeft er voor gezorgd dat er al veel onderzoek naar gedaan is. Ook in ons geval is er al veel met het Firefly-algoritme geëxperimenteerd. Gezien de toepasbaarheid in grotere draadloze netwerken, is er veel getest op het gebied van transmissie delay en het feit dat een node niet tegelijkertijd kan zenden en ontvangen.

Daarnaast moet het netwerk zichzelf kunnen organiseren. Heel simpel gezegd bestaat het netwerk uit een heleboel kleine, op zichzelf staande entiteiten die simpele gedragsregels kennen. Ze hebben elk een beperkt lokaal zicht op het netwerk. Al deze kleine entiteiten vormen samen het netwerk. Dit grote systeem is adaptief waardoor veranderingen in het netwerk geen problemen voor het netwerk in zijn geheel opleveren. Tevens is het netwerk volledig schaalbaar.

In feite zijn er een aantal mogelijkheden om een synchronisatiestrategie te bedenken voor zo'n netwerk. Er kan gekozen worden voor een master-slave implementatie, mutual synchronization of een combinatie van die twee. In de echte wereld kennen we dit als een monarchie, een democratie of een oligarchie. Een voorbeeld van een master-slave implementatie is bijvoorbeeld het Berkeley algoritme dat wordt gebruikt in LAN-synchronisatie. Waar wij naartoe willen is een implementatie van het tweede principe; mutual synchronization.

Het firefly-algoritme is ook op dit principe gebaseerd. Dit algoritme gaat er vanuit dat synchronisatie pulsen oneindig kort zijn, er geen delays zijn, nodes tegelijkertijd kunnen luisteren en versturen en dat alle nodes samen een compleet netwerk vormen. Waarneer er aan een of meerdere van deze aannames niet voldaan wordt, is synchronsatie onstabiel. Hierdoor is het onhaalbaar om dit een op een door te zetten naar draadloze systemen. Een voorbeeld waarom het niet zou kunnen werken is dat als er delays zijn, het mogelijk is dat nodes "echos" ontvangen van hun eigen puls.

Gelukkig is hiervoor een alternatief beschikbaar, namelijk het Meshed Emergent Firefly Synchronization (MEMFIS) algoritme. Dit algoritme houdt rekening met de technologische beperkingen van draadloze netwerken met behoud van de eigenschappen van firefly synchronisatie. Een belangrijk kenmerk van het ontwerp is dat er een gemeenschappelijk synchronisatiewoord is ingebed in elk payload packet. Dit synschonisatiewoord wordt gedetecteerd bij de ontvanger door gebruik te maken van een cross-correlator. Delays worden afgehandeld door het synchronisatiealgoritme te verbeteren. Het resultaat is dat   geleidelijk ontstaat als nodes onderling willekeurig pakketen uitwisselen. Hierdoor is er ook geen speciale synchornisatiefase nodig.


\section{Radiosynchronisatie}\label{sec:radiosync}
Patrick
\todo[inline]{dit is niet af :(}

Om tijdsynchronisatie op Arduinos uit te kunnen voeren, is een middel nodig waarmee dat gedaan wordt. In dit geval gebruiken we hier een radio voor. Hierdoor kunnen de Arduinos onderling met elkaar communiceren. Op deze manier kunnen ze synchroon gaan lopen door elkaar te informeren over hun status.

Onze Arduinos zijn allemaal met een ledje uitgerust om zo een firefly na te bootsen. De frequentie van het knipperen van een ledje is vantevoren vastgelegd. Telkens wanneer een node zijn ledje laat knipperen, zend deze een radiosignaal uit. Wanneer andere nodes deze oppikken (dus in hun luisterfase zitten), zullen zij zich de volgende ronde hierop aanpassen volgens het algoritme. Na enige tijd zullen de Arduinos nagenoeg synchroon hun ledje laten knipperen.

\section{Tjirpende Arduino's}\label{sec:geluidssec}
De implementatie beschreven in de vorige secties is niet afhankelijk van het precieze signaal dat de Arduino's geven. Het is alleen afhankelijk van het moment waarop het signaal uitgezonden en ontvangen wordt, en de tijd hiertussen mag niet exorbitant groot worden of wisselend lang en kort duren.

In plaats van een radiosignaal kunnen ook andere signalen uitgewisseld worden, bijvoorbeeld een geluidssignaal. De implementatie hiervan heeft wel wat meer voeten in de aarde, omdat er erg veel ruis is in de vorm van omgevingsgeluid. Tevens heeft de Arduino niet een standaardimplementatie die "pieken" kan detecteren; er is dus geen functie voor microfoons die vergelijkbaar is met \texttt{radio.available()}.

\subsection{Analoge signaalverwerking}
Een microfoon levert geen geschikt signaal op dat digitaal verwerkt kan worden. Het signaal is te zacht, bevat veel ruis en is analoog. Om het door de Arduino te laten verwerken moet het signaal versterkt worden en omgezet worden naar een digitaal signaal. Dit doen we in drie stappen:

\begin{itemize}
	\item \textit{High-pass filter:} dit filter laat alleen de tonen boven een bepaalde ondergrens door, waardoor lage omgevingsgeluiden gefilterd worden. Dit vermindert dus de hoeveelheid ruis in het signaal.
	\item \textit{Versterker:} omdat de microfoon een zwak signaal levert, moet het versterkt worden.
	\item \textit{Omzetten naar digitaal signaal:} met behulp van een ADC (analog to digital converter) kan het gefilterde, versterke signaal omgezet worden naar een digitale input.
\end{itemize}

Het circuit dat voor dit onderzoek gebruikt is, staat in figuur~\ref{fig:circuit}. Hierbij wordt gebruik gemaakt van de ADC die standaard beschikbaar is op de Arduino Uno, die een analoog input signaal tussen 0 en 5 volt heeft en als digitale output een getal tussen de 0 en 1024 geeft.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{high_pass_filter_circuit.png}
    \caption{High-pass filter met versterker en ADC.\\\textit{Bron: CreaTe Protobox quick reference sheet.}}
    \label{fig:circuit}
\end{figure}

\subsection{Signaalverwerking}
In figuur~\ref{fig:on_off} is zichtbaar dat het versturen van een geluidssignaal een sterk wisselend inputsignaal geeft. We kunnen dus stellen dat als het verschil tussen twee opeenvolgende metingen erg verschilt, dat er dan zeer waarschijnlijk een signaal ontvangen wordt. Neem $v(t)$ de waarde gemeten op tijdstip $t$ zijn, dan $|v(t) - v(t+1)| > \text{threshold} \Rightarrow \text{signaal ontvangen}$.

Hierbij is het van belang dat de threshold hoog genoeg gekozen wordt om ruis uit te sluiten, maar ook niet zo hoog dat signalen niet opgemerkt worden. Omdat dit moeilijk van tevoren vast te stellen is, hebben we gebruik gemaakt van een dynamische threshold gebaseerd op de gemiddelde afwijking. De gemiddelde afwijking (avgdiff) als functie van de tijd is

$$\text{avgdiff}(t+1) = 0.1\cdot |v(t) - v(t+1)| + 0.9\cdot\text{avgdiff}(t)$$

Dit is dus een gemiddelde van de afwijkingen tussen metingen, waarbij het "gewicht" van een meting exponentieel snel afneemt. De eerste meting telt dus vrijwel niet mee, en de laatste meting relatief zwaar (10\%). De threshold is $3\cdot\text{avgdiff}$: als metingen meer dan drie keer zoveel verschillen als gemiddeld, gaan we ervanuit dat er een signaal ontvangen wordt.

\section{Resultaten en discussie}\label{sec:resultaten}
Bram
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{resonance_on_off_commit_ff82f.png}
    \caption{Inkomend signaal bij pulserend signaal.}
    \label{fig:on_off}
\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{resonance_2_frequencies_commit_ff82f.png}
    \caption{Inkomend signaal bij verschillende geluidsfrequencies.}
    \label{fig:resonance}
\end{figure}
Het werkt
Microfoon veel last omgevingsgeluid; hogere frequentie?
Radiosync werkt goed; weinig ruis en op grote(re) afstand beschikbaar.

\section{Conclusie}\label{sec:conclusie}
Bram
Concluderend, we hebben succesvol een algoritme kunnen maken en deze geÃ¯mplementeerd op onze Arduino's. 

% \newpage
% \appendix
% \section{Bijlage 1 - Code}
% \label{sec:code}
% \input{code_formatted}

\bibliographystyle{plain}
\bibliography{verslag_week_4}

\end{document}
